{
    "version": "https://jsonfeed.org/version/1",
    "title": "딥백수 • All posts by \"go\" tag",
    "description": "우리는 '지속가능한 백수질'을 지향합니다. 고로 외롭게 공부하고 있을 당신을 응원합니다. 딥러닝에 관련된 글 뿐만 아니라, 백수생활의 넋두리도 환영합니다.",
    "home_page_url": "https://deepbaksu.github.io",
    "items": [
        {
            "id": "https://deepbaksu.github.io/2021/05/01/how-to-REST-from-gRPC/",
            "url": "https://deepbaksu.github.io/2021/05/01/how-to-REST-from-gRPC/",
            "title": "gRPC에서 REST까지",
            "date_published": "2021-05-01T20:43:00.000Z",
            "content_html": "<p>gRPC를 통해 REST 서버를 만들어 보자. gRPC 클라이언트로 연결할 수 있으면 좋지만, REST가 보편적이기 때문에 REST API를 구현해줘야 할 필요가 있다. 또한, Heroku에서는 HTTP/2 를 지원하지 않기 때문에 gRPC 를 사용할 수 없어, 어쩔 수 없이 HTTP/1.1 REST API를 노출해줘야 한다.</p>\n<p>gRPC서버를 만들어놓으면</p>\n<ul>\n<li>REST 서버</li>\n<li>OpenAPI (Swagger)</li>\n<li>OpenAPI 를 통한 클라이언트 코드</li>\n</ul>\n<p>가 자동으로 생기게 된다. Protocol Buffer를 사용하기에 타입에 대한 걱정도 없어진다.</p>\n<h2 id=\"why-grpc\"><a class=\"markdownIt-Anchor\" href=\"#why-grpc\"></a> Why gRPC?</h2>\n<p>gRPC는 Protocol Buffer를 사용해 정의한다. Protocol Buffer를 사용해서 정의해두면 클라이언트와 서버 코드 모두 생성 가능해 전송되는 데이터의 형식에 대해서 걱정하지 않아도 된다.</p>\n<p>예를 들어, 클라이언트에서는 underscore 인줄 알고 보냈는데</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;my_name&quot;</span>: <span class=\"string\">&quot;ABC&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>서버에서는 camelCase의 형식으로 생각하고 적을 수 도 있다.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;myName&quot;</span>: <span class=\"string\">&quot;ABC&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>또한, API를 먼저 protobuf로 정의해두어야 하기 때문에 API first development가 가능하다.<br />\n게다가, OpenAPI 스펙 또한 생성 가능해서 Swagger UI 뿐만 아니라 클라이언트 코드 생성이 쉽게 가능하다.</p>\n<h2 id=\"how\"><a class=\"markdownIt-Anchor\" href=\"#how\"></a> How?</h2>\n<p><img src=\"/2021/05/01/how-to-REST-from-gRPC/overview.svg\" alt=\"Overview\" /></p>\n<p><a href=\"https://github.com/grpc-ecosystem/grpc-gateway\">gRPC Gateway</a> 를 사용한다.</p>\n<p>그림에서는 gRPC Gateway 와 gRPC Server가 나뉘어져 있지만 간단한 서버라면 하나의 서버/하나의 포트에서 실행시킬 수 도 있다.</p>\n<h3 id=\"비슷한-방법들\"><a class=\"markdownIt-Anchor\" href=\"#비슷한-방법들\"></a> 비슷한 방법들</h3>\n<p>아래 두개 모두 gRPC Gateway 와 비슷한 기능을 한다. 하지만 gRPC Gateway의 장점은 하나의 서버에서 하나의 포트에서 gRPC와 REST Endpoint를 동시에 서빙 가능하다는 점이다.</p>\n<ul>\n<li>gRPC-Web</li>\n<li>Extensible Service Proxy (ESP)</li>\n</ul>\n<h2 id=\"code\"><a class=\"markdownIt-Anchor\" href=\"#code\"></a> Code</h2>\n<p>protobuf에서 <code>google.api.http</code>를 사용해 REST API를 설정해주기만 하면 된다.</p>\n<figure class=\"highlight protobuf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = <span class=\"string\">&quot;proto3&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">package</span> blog.v1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;google/api/annotations.proto&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">BlogService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">rpc</span> CreatePost (CreatePostRequest) <span class=\"keyword\">returns</span> (CreatePostResponse) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">option</span> (google.api.http) = &#123;</span><br><span class=\"line\">            post: <span class=\"string\">&quot;/v1/blog&quot;</span></span><br><span class=\"line\">            body: <span class=\"string\">&quot;*&quot;</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">rpc</span> GetPosts (GetPostsRequest) <span class=\"keyword\">returns</span> (GetPostsResponse) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">option</span> (google.api.http) = &#123;</span><br><span class=\"line\">            get: <span class=\"string\">&quot;/v1/blog/&#123;post_id&#125;&quot;</span></span><br><span class=\"line\">            additional_bindings &#123;</span><br><span class=\"line\">                get: <span class=\"string\">&quot;/v1/blog&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">rpc</span> DeletePost (DeletePostRequest) <span class=\"keyword\">returns</span> (DeletePostResponse) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">option</span> (google.api.http) = &#123;</span><br><span class=\"line\">            delete: <span class=\"string\">&quot;/v1/blog/&#123;post_id&#125;&quot;</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>예를 들어, <code>POST /v1/blog</code>를 보내면 <code>BlogService.CreatePost</code> RPC를 실행시킨다.</p>\n<p>프로토 파일을 정의했으면 <code>protoc</code> 나 <code>buf</code> 를 사용해 코드를 생성해주기만 하면 된다.</p>\n<p>Buf를 사용할 경우, <code>buf.gen.yaml</code> 를 아래와 같이 생성하고 <code>buf generate</code> 하면 된다.</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># buf.gen.yaml</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">v1beta1</span></span><br><span class=\"line\"><span class=\"attr\">plugins:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">go</span></span><br><span class=\"line\">    <span class=\"attr\">out:</span> <span class=\"string\">gen/go</span></span><br><span class=\"line\">    <span class=\"attr\">opt:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">paths=source_relative</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">go-grpc</span></span><br><span class=\"line\">    <span class=\"attr\">out:</span> <span class=\"string\">gen/go</span></span><br><span class=\"line\">    <span class=\"attr\">opt:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">paths=source_relative</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">grpc-gateway</span></span><br><span class=\"line\">    <span class=\"attr\">out:</span> <span class=\"string\">gen/go</span></span><br><span class=\"line\">    <span class=\"attr\">opt:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">paths=source_relative</span></span><br></pre></td></tr></table></figure>\n<p>하나의 바이너리에서 gRPC Gateway 와 gRPC Server를 동시에 서빙하는 Go 서버 파일은 다음과 같다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> port = flag.Int(<span class=\"string\">&quot;port&quot;</span>, <span class=\"number\">80</span>, <span class=\"string\">&quot;--port 80&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> blogImpl <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">  posts []*v1.Post</span><br><span class=\"line\">  v1.UnimplementedBlogServiceServer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 헤더를 보고 Content-Type: application/grpc 라면 gRPC 서버 핸들러를 이용하고</span></span><br><span class=\"line\"><span class=\"comment\">// 그 이외에 경우는 REST API이기 때문에 Gateway 핸들러에게 보내준다.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">allHandler</span><span class=\"params\">(grpcServer *grpc.Server, httpHandler http.Handler)</span> <span class=\"title\">http</span>.<span class=\"title\">Handler</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> h2c.NewHandler(http.HandlerFunc(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.ProtoMajor == <span class=\"number\">2</span> &amp;&amp; strings.Contains(r.Header.Get(<span class=\"string\">&quot;Content-Type&quot;</span>), <span class=\"string\">&quot;application/grpc&quot;</span>) &#123;</span><br><span class=\"line\">      grpcServer.ServeHTTP(w, r)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      httpHandler.ServeHTTP(w, r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;), &amp;http2.Server&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  flag.Parse()</span><br><span class=\"line\"></span><br><span class=\"line\">  addr := fmt.Sprintf(<span class=\"string\">&quot;:%d&quot;</span>, *port)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// gRPC 서버 생성</span></span><br><span class=\"line\">  grpcServer := grpc.NewServer()</span><br><span class=\"line\">  v1.RegisterBlogServiceServer(grpcServer, &amp;blogImpl&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// gRPC Gateway 생성</span></span><br><span class=\"line\">  gwmux := runtime.NewServeMux()</span><br><span class=\"line\">  err := v1.RegisterBlogServiceHandlerFromEndpoint(context.Background(), gwmux, addr, []grpc.DialOption&#123;grpc.WithInsecure()&#125;)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  err = http.ListenAndServe(addr, allHandler(grpcServer, gwmux))</span><br><span class=\"line\">  <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그러면 완성이다. 서버를 실행한 후 REST API가 제대로 작동하는지 <code>curl</code> 을 사용해 확인할 수 있다.</p>\n<p><code>POST /v1/blog</code> 를 통해 새로운 블로그 포스트 생성.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> curl -X <span class=\"string\">&#x27;POST&#x27;</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"string\">&#x27;https://grpc-gateway-example.herokuapp.com/v1/blog&#x27;</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">  -H <span class=\"string\">&#x27;accept: application/json&#x27;</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">  -H <span class=\"string\">&#x27;Content-Type: application/json&#x27;</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">  -d <span class=\"string\">&#x27;&#123;</span></span></span><br><span class=\"line\">  &quot;content&quot;: &quot;내용 내용 내용&quot;</span><br><span class=\"line\">&#125;&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;post&quot;: &#123;</span><br><span class=\"line\">    &quot;id&quot;: &quot;1619938066293158896&quot;,</span><br><span class=\"line\">    &quot;content&quot;: &quot;내용 내용 내용&quot;,</span><br><span class=\"line\">    &quot;createdAt&quot;: &quot;2021-05-02T06:47:46.293159328Z&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>GET /v1/blog</code> 를 통해 작성된 블로그 포스트 가져오기.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> curl -X <span class=\"string\">&#x27;GET&#x27;</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"string\">&#x27;https://grpc-gateway-example.herokuapp.com/v1/blog&#x27;</span> \\</span></span><br><span class=\"line\"><span class=\"bash\">  -H <span class=\"string\">&#x27;accept: application/json&#x27;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;posts&quot;: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &quot;id&quot;: &quot;1619938066293158896&quot;,</span><br><span class=\"line\">      &quot;content&quot;: &quot;내용 내용 내용&quot;,</span><br><span class=\"line\">      &quot;createdAt&quot;: &quot;2021-05-02T06:47:46.293159328Z&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>정리하면, gRPC 를 사용할 경우</p>\n<ul>\n<li>완전한 API First Development가 가능하다.\n<ul>\n<li>일반적인 경우 swagger.json 파일을 손으로 작성하기 매우 까다롭기 때문에 API First Development가 매우 어렵다.</li>\n</ul>\n</li>\n<li>인터페이스가 프로토콜버퍼에 정의되어 있어 클라이언트와 서버와 서로 잘못된 데이터를 사용하는 일이 없다.</li>\n<li>코드가 자동으로 생성되어 boilerplate 코드를 훨씬 줄일 수 있다.</li>\n</ul>\n<p>실제 이 코드는</p>\n<p><img src=\"/2021/05/01/how-to-REST-from-gRPC/swagger.png\" alt=\"Protobuf에서 생성된 Swagger UI\" /></p>\n<ul>\n<li><a href=\"https://grpc-gateway-example.herokuapp.com/swagger-ui\">https://grpc-gateway-example.herokuapp.com/swagger-ui</a> 에서 테스트 가능하다.</li>\n</ul>\n<p>더 자세한 코드는 <a href=\"https://github.com/kkweon/grpc-rest-via-gateway\">https://github.com/kkweon/grpc-rest-via-gateway</a> 에서 볼 수 있다.</p>\n",
            "tags": [
                "gRPC",
                "Go",
                "REST"
            ]
        },
        {
            "id": "https://deepbaksu.github.io/2020/10/20/play-with-slice-of-golang/",
            "url": "https://deepbaksu.github.io/2020/10/20/play-with-slice-of-golang/",
            "title": "Go 슬라이스 가지고 놀아보자",
            "date_published": "2020-10-20T09:17:05.000Z",
            "content_html": "<p><img src=\"/2020/10/20/play-with-slice-of-golang/nery-montenegro-3ak9PMcx048-unsplash.jpg\" alt=\"Photo by Nery Montenegro on Unsplash\" /></p>\n<p>Go의 슬라이스는 배열과 비슷한 듯 다르다. 슬라이스는 세 개의 필드를 가진 데이터 구조이다.</p>\n<ol>\n<li>포인터: 실제 값이 들어있는 배열의 주소를 가리킨다</li>\n<li>Length: 값이 들어있는 길이를 가리킨다.</li>\n<li>Capacity: 실제 값은 들어있지 않지만 미리 확보해놓은 메모리 공간이라 생각하면 된다.</li>\n</ol>\n<p><img src=\"/2020/10/20/play-with-slice-of-golang/1.jpg\" alt=\"slice in golang: https://www.geeksforgeeks.org/slices-in-golang\" /></p>\n<p><code>Capacity</code> 이내 에서는 <code>append</code>를 하더라도 다른 곳으로 메모리를 재할당 할 필요가 없다. 저장하는 메모리 공간을 이사할 필요가 없다는 것이다.</p>\n<p>적절할지 모르겠지만 비유를 해본다. 아파트의 방에 한 명씩 살아야 한다고 하자. 방 4개 짜리 아파트에 (cap<mark>4) 세 명이 각각 방 하나씩을 차지하고 있는 경우 (len</mark>3) 한명이 더 들어와 살더라도 방 5, 6개 짜리 아파트로 이사할 필요가 없는 것이다. 하지만 여기서 한 명이라도 더 들어오면 방이 더 많은, 다른 아파트로 이사를 해야 한다.</p>\n<p>이론적인 부분은 이만 줄이고 실제 코드로 부딪혀가며 이해해보자.</p>\n<h2 id=\"실습\"><a class=\"markdownIt-Anchor\" href=\"#실습\"></a> 실습</h2>\n<p>실습을 통해 다음과 같은 상황을 확인해보자<br />\n같은 배열을 가리키는 두 슬라이드가 있다고 할 때에</p>\n<ol>\n<li>같은 메모리 주소의 하나의 값을 변경하면 나머지 하나도 바뀔 것이다. 슬라이스의 포인터가 같은 배열을 가리키고 있기 때문이다.</li>\n<li>그러면 두 슬라이스 중에 하나가 다른 하나의 일부일 때에, 그 슬라이스를 append 한다면?\n<ul>\n<li>cap 이내일때는 여전히 같은 배열을 가리키겠지만</li>\n<li>cap 을 넘어서는 append 의 경우에는 두 슬라이스는 다른 배열을 가리키게 될 것이다.</li>\n</ul>\n</li>\n<li>슬라이스를 함수에 값으로 전달한다면 어떻게 될까?\n<ul>\n<li>슬라이스가 복제된다. 포인터는 같은 배열을 가리킨다.</li>\n<li>하지만 함수 내에서 슬라이스의 len, cap 을 변경해도 원래 슬라이스의 len, cap은 변하지 않을 것이다.<br />\n→ 같은 배열을 가리키는 두 개의 별개의 슬라이스인 것이다.</li>\n</ul>\n</li>\n<li>슬라이스를 함수에 포인터로 전달한다면 어떻게 될까?\n<ul>\n<li>포인터, len, cap 이 온전히 전달되고,</li>\n<li>함수내에서 이들이 바뀌면 원본 역시 변할 것이다.</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"배열-함께-쓰기-이별하기\"><a class=\"markdownIt-Anchor\" href=\"#배열-함께-쓰기-이별하기\"></a> 배열 함께 쓰기, 이별하기</h3>\n<p>Play ground: <a href=\"https://play.golang.org/p/RxLFuykp9XH\">https://play.golang.org/p/RxLFuykp9XH</a></p>\n<p>(1) a, b, c 슬라이스는 모두 같은 배열을 가리키고 있다.</p>\n<ul>\n<li>b는 len은 2이지만, cap은 a의 cap 나머지와 같은 3이다.</li>\n<li>c와 같이 cap도 정확히 설정할 수 있다.</li>\n</ul>\n<p>(2) b 슬라이스를 append 해도 아직 여분의 cap 공간이 있다</p>\n<ul>\n<li>그래서 b 슬라이스가 메모리 이사를 갈 필요가 없다.</li>\n<li>그래서 a[5]와 b[3]의 값이 함께 바뀐다.</li>\n<li>포인터가 가리키는 배열의 같은 위치 원소의 주소값도 같다.</li>\n</ul>\n<p>(3) b 슬라이스를 한 번더 append 해보자</p>\n<ul>\n<li>이제는 b 슬라이스가 이사를 가야한다.</li>\n<li>포인터가 가리키는 배열의 같은 위치였을 원소의 주소값이 다르다.</li>\n<li>(4)를 보면 이제 완전히 별개의 두 배열을 가리키고 있는 것을 알 수 있다.</li>\n</ul>\n<p><img src=\"/2020/10/20/play-with-slice-of-golang/2.png\" alt=\"example code1\" /></p>\n<h3 id=\"함수에-슬라이스-전달하기\"><a class=\"markdownIt-Anchor\" href=\"#함수에-슬라이스-전달하기\"></a> 함수에 슬라이스 전달하기</h3>\n<p>Play ground: <a href=\"https://play.golang.org/p/5qg7NVNH2Ic\">https://play.golang.org/p/5qg7NVNH2Ic</a></p>\n<p>(1) len 5, cap 5 인 a 슬라이스를 만들었다.</p>\n<p>(2) (3) 은 각각 슬라이스와 슬라이스 주소값을 전달받는 함수를 선언하였다.</p>\n<ul>\n<li>슬라이스의 첫번째 원소의 값을 바꾸고</li>\n<li>슬라이스에 빈 원소 3개를 append 한 다음</li>\n<li>함수 안에서 슬라이스의 변경된 길이를 출력해 보았다.</li>\n</ul>\n<p>(4) 함수를 실행해보니</p>\n<ul>\n<li>\n<p>a 슬라이스는 len 5, cap 5로 생성이 되어있고</p>\n</li>\n<li>\n<p>changeSliceValue 함수의 경우는 - a 슬라이스의</p>\n<ul>\n<li>첫번째 원소의 값은 바꾸었지만</li>\n<li>len, cap 은 바꾸지 못하였다.</li>\n</ul>\n</li>\n<li>\n<p>changeSliceReference 함수의 경우는 a 슬라이스의</p>\n<ul>\n<li>첫번째 원소의 값을 바꾸었고</li>\n<li>len, cap 까지도 바꾸었다.</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2020/10/20/play-with-slice-of-golang/3.png\" alt=\"example code2\" /></p>\n",
            "tags": [
                "Hyunseok Jeong",
                "Go",
                "Golang",
                "Slice",
                "example"
            ]
        },
        {
            "id": "https://deepbaksu.github.io/2020/08/21/Go-wire-dependency-injection-tutorial/",
            "url": "https://deepbaksu.github.io/2020/08/21/Go-wire-dependency-injection-tutorial/",
            "title": "Go Dependency Injection Tutorial (feat. Wire)",
            "date_published": "2020-08-21T15:15:25.000Z",
            "content_html": "<p>Dependency Injection(DI)을 한국어로 의존성 주입이라고도 하지만 실제로는 DI라고 했을때 우리는 DI Framework/Library 를 의미합니다. 우선 Dependency Injection 이 무엇인지 에 대해 설명하겠습니다.</p>\n<p>예를 들어 <code>PostService</code> 는 블로그 포스트를 작성해주는 서비스가 있다고 가정합니다.</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PostService <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  CreatePost(Post) Post</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이때 우리는 블로그 포스트를 데이터베이스에 저장하고 싶습니다. 그러기 위해서 <code>CreatePost(Post)</code> 함수 안에서</p>\n<ol>\n<li>데이터베이스에 연결하고</li>\n<li>Post 를 INSERT 한다.</li>\n</ol>\n<p>이런식으로 할 수 도 있습니다. 하지만 이런식으로 하기보다는 비지니스 로직과 데이터베이스를 다루는 코드를 분리하여 데이터베이스에 저장하는 코드는 <code>PostRepository</code> 에 대행시킬 것입니다.</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PostRepository <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">  StorePost(Post) <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/2020/08/21/Go-wire-dependency-injection-tutorial/architecture.jpg\" alt=\"Architecture\" /></p>\n<p>즉 보시다싶이 <code>PostService</code> 가 <code>PostRepository</code> 에 의존하고 있습니다.<br />\n그러면 <code>PostService</code> 를 생성하기 위해 다음과 같은 코드를 작성할 것입니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPostService</span><span class=\"params\">(repo PostRepository)</span> <span class=\"title\">PostService</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;postService&#123;</span><br><span class=\"line\">\t\tRepo: repo,</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이게 Dependency Injection 입니다. 이때 만약 Postgres가 아니라 Sqlite 나 심지어 메모리에 저장하고 싶으면 어떻게 될까요? 그에 해당하는 PostRepository 객체를 바꿔껴주기만 하면 됩니다.</p>\n<p><img src=\"/2020/08/21/Go-wire-dependency-injection-tutorial/different_repository.svg\" alt=\"InMemoryPostRepository\" /></p>\n<p>이렇게 의존성이 간단하면 Dependency Injection 프레임워크가 없더라도 손으로 Dependency Injection 설계도 가능합니다. 하지만 이렇게 의존하는 서비스가 많아진다면?</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPostService</span><span class=\"params\">(someService SomeService, otherService OtherService, repo PostRepository, ...)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.go</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  otherSerivce := NewOtherService(<span class=\"string\">&quot;secret&quot;</span>)</span><br><span class=\"line\">  someService := NewSomeService(otherService)</span><br><span class=\"line\">  postRepository := NewPostRepository(<span class=\"string\">&quot;dburl&quot;</span>)</span><br><span class=\"line\">  potService := NewPostService(someService, otherService, postRepository)</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>일일히 손으로 바꿔주는게 매우 귀찮고 손이 많이갑니다. 순서도 맞춰줘야 되고 argument 위치나 귀찮은게 한두가지가 아닙니다. 이걸 자동으로 해주는 것이 바로 Dependency Injection Framework 이고 Go 에서는 <a href=\"https://github.com/google/wire\">wire</a> 와 <a href=\"https://github.com/uber-go/fx\">fx</a> 가 있습니다.</p>\n<h2 id=\"준비물\"><a class=\"markdownIt-Anchor\" href=\"#준비물\"></a> 준비물</h2>\n<p>여기서는 구글의 <a href=\"https://github.com/google/wire\">wire</a> 를 사용하도록 하겠습니다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get github.com/google/wire/cmd/wire</span><br></pre></td></tr></table></figure>\n<h2 id=\"프로젝트-구조\"><a class=\"markdownIt-Anchor\" href=\"#프로젝트-구조\"></a> 프로젝트 구조</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── cmd</span><br><span class=\"line\">│   └── server.go</span><br><span class=\"line\">├── go.mod</span><br><span class=\"line\">├── go.sum</span><br><span class=\"line\">├── module</span><br><span class=\"line\">│   └── wire.go</span><br><span class=\"line\">└── post</span><br><span class=\"line\">    ├── postrepository.go</span><br><span class=\"line\">    └── postservice.go</span><br><span class=\"line\"></span><br><span class=\"line\">3 directories, 6 files</span><br></pre></td></tr></table></figure>\n<p>각 <code>postservice.go</code> 와 <code>postrepository.go</code> 파일은 이전에서 본것과 동일합니다.</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// postservice.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> post</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// (skip)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PostService 를 생성하는 factory function</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewPostService</span><span class=\"params\">(repository PostRepository)</span> *<span class=\"title\">PostService</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;PostService&#123;Repo: repository&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// postrepository.go</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> post</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> PostRepository <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tStorePost(Post) <span class=\"keyword\">bool</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> InMemoryPostRepository <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">\tcache <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]Post</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(i *InMemoryPostRepository)</span> <span class=\"title\">StorePost</span><span class=\"params\">(post Post)</span> <span class=\"title\">bool</span></span> &#123;</span><br><span class=\"line\">\ti.cache[post.id] = post</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 인메모리 포스트리포지토리를 생성하는 팩토리 함수</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NewInMemoryPostRepository</span><span class=\"params\">()</span> <span class=\"title\">PostRepository</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;InMemoryPostRepository&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 <code>module/wire.go</code> 파일은 다음과 같습니다.</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//+build wireinject  &lt;--- 매우 중요</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">package</span> module</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;example/post&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/google/wire&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitializePostService</span><span class=\"params\">()</span> *<span class=\"title\">post</span>.<span class=\"title\">PostService</span></span> &#123;</span><br><span class=\"line\">\twire.Build(post.NewInMemoryPostRepository, post.NewPostService) <span class=\"comment\">// &lt;-- Factory 함수들</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;post.PostService&#123;&#125; <span class=\"comment\">// &lt;-- Return Type을 마추기 위한 더미로 중요하지 않음</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 shell 에서 <code>wire</code> 커맨드를 치면 코드가 생성이 됩니다.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wire module/wire.go</span><br></pre></td></tr></table></figure>\n<p>아래는 생성된 코드입니다. <code>PostRepository</code> 와 <code>PostService</code> 가 올바른 순서로 생성된 것을 볼 수 있습니다.</p>\n<figure class=\"highlight golang\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">InitializePostService</span><span class=\"params\">()</span> *<span class=\"title\">post</span>.<span class=\"title\">PostService</span></span> &#123;</span><br><span class=\"line\">\tpostRepository := post.NewInMemoryPostRepository()</span><br><span class=\"line\">\tpostService := post.NewPostService(postRepository)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> postService</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자세한 내용은 <a href=\"https://bit.ly/2Sqdnws\">https://bit.ly/2Sqdnws</a> 에 참여하셔서 문의주세요 😄</p>\n",
            "tags": [
                "Mo Kweon",
                "go",
                "golang",
                "dependency injection",
                "wire",
                "uber-go",
                "fx"
            ]
        },
        {
            "id": "https://deepbaksu.github.io/2020/08/17/slack-bot/",
            "url": "https://deepbaksu.github.io/2020/08/17/slack-bot/",
            "title": "슬랙봇 Distribute 가능하게 만들기 (OAuth)",
            "date_published": "2020-08-17T08:32:54.000Z",
            "content_html": "<p>딥백수에는 여러 슬랙봇들이 상주하고 있습니다.</p>\n<p><img src=\"/2020/08/17/slack-bot/timebot_demo.png\" alt=\"캘리포니아/한국 시간 변환해주는 timebot\" /></p>\n<p>이렇게 만들어 둔 봇이 유용해서 다른 슬랙 workspace 에서 사용하고 싶을 때가 있습니다. 그러기 위해 distribute 가능하게 봇을 작성해야 합니다. 그러기 위해 OAuth를 사용해야 합니다.</p>\n<h2 id=\"oauth-란\"><a class=\"markdownIt-Anchor\" href=\"#oauth-란\"></a> OAuth 란?</h2>\n<p>OAuth는 엑세스를 관리하는 방법중에 표준으로 사용되는 방법입니다. A라는 애플리케이션에서 B사이트의 유저 정보가 필요하다면 B사이트로 OAuth Request 를 보내는 방식입니다.</p>\n<p>여기서 슬랙봇이 A 애플리케이션이고 슬랙이 B에 해당합니다.</p>\n<h2 id=\"실제-slack-작동-구조\"><a class=\"markdownIt-Anchor\" href=\"#실제-slack-작동-구조\"></a> 실제 Slack 작동 구조</h2>\n<p><img src=\"https://a.slack-edge.com/fbd3c/img/api/articles/oauth_scopes_tutorial/slack_oauth_flow_diagram.png\" alt=\"OAuth\" /></p>\n<p>위 그림에서 구현해야 될게 많은 것으로 보이지만 실제로 <code>GET /api/oauth?code=XXXXX</code> 엔드포인트를 서버에 만들어주고 토큰을 저장할 데이터베이스만 있으면 완성입니다.</p>\n<p>예를 들어, 유저가 <a href=\"https://slack.com/oauth/v2/authorize?client_id=288745980535.515443770183&scope=channels:history,channels:join,channels:read,chat:write,chat:write.customize,chat:write.public,commands,dnd:read,emoji:read,groups:history,groups:read,groups:write,im:history,im:read,im:write,links:read,links:write,mpim:history,mpim:read,mpim:write,pins:read,pins:write,reactions:read,reactions:write,reminders:read,reminders:write,remote_files:read,remote_files:share,remote_files:write,team:read,usergroups:read,usergroups:write,users.profile:read,users:read,users:read.email,users:write,app_mentions:read&user_scope=\"><img alt=\"Add to Slack\" height=\"40\" width=\"139\" src=\"https://platform.slack-edge.com/img/add_to_slack.png\" srcSet=\"https://platform.slack-edge.com/img/add_to_slack.png 1x, https://platform.slack-edge.com/img/add_to_slack@2x.png 2x\" /></a> 이 버튼을 누르고 동의를 하게 되면 timebot 서버로 GET /api/oauth?code=XXXX 리퀘스트를 보내게 됩니다. (step 2 에 해당)</p>\n<p>그럼 이 code=XXX 를 사용하여 슬랙 서버에 OAuth 요청을 보내고(step 3) 받은 토큰을 데이터베이스에 저장해주면 됩니다 (step 4).</p>\n<p>수도 코드는 아래와 같이 되어 있습니다.</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">OauthHandler</span><span class=\"params\">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// GET ?code=XXXX 읽음</span></span><br><span class=\"line\">  code, ok := request.URL.Query()[<span class=\"string\">&quot;code&quot;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CODE를 보냄 (POST https://api.slack.com/methods/oauth.v2.access)</span></span><br><span class=\"line\">  resp, err := getOAuthV2Response(slackClientId, slackClientSecret, code[<span class=\"number\">0</span>], <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// TeamID 및 AccessToken 저장</span></span><br><span class=\"line\">  store(resp.TeamID, resp.AccessToken)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ... send ok response</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>POST https://api.slack.com/methods/oauth.v2.access</code> 의 예시 response</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;ok&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;access_token&quot;</span>: <span class=\"string\">&quot;xoxb-17653672481-19874698323-pdFZKVeTuE8sk7oOcBrzbqgy&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;token_type&quot;</span>: <span class=\"string\">&quot;bot&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;scope&quot;</span>: <span class=\"string\">&quot;commands,incoming-webhook&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;bot_user_id&quot;</span>: <span class=\"string\">&quot;U0KRQLJ9H&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;app_id&quot;</span>: <span class=\"string\">&quot;A0KRD7HC3&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;team&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Slack Softball Team&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"string\">&quot;T9TK3CUKW&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;enterprise&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;slack-sports&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"string\">&quot;E12345678&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;authed_user&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"string\">&quot;U1234&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;scope&quot;</span>: <span class=\"string\">&quot;chat:write&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;access_token&quot;</span>: <span class=\"string\">&quot;xoxp-1234&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;token_type&quot;</span>: <span class=\"string\">&quot;user&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이때 TeamID(workspace) 와 코드를 함께 저장해주면 나중에 유저 메시지로부터 반응하는 봇을 만들때 유저 메시지에 포함된 TeamID를 읽어 Access Token 을 DB에서 불러오는 식으로 사용합니다.</p>\n<p><img src=\"/2020/08/17/slack-bot/timebot_sequential.svg\" alt=\"timebot 순서도\" /></p>\n<p>자세한 내용은 <a href=\"https://bit.ly/2Sqdnws\">https://bit.ly/2Sqdnws</a> 에 참여하셔서 문의주세요 😄</p>\n",
            "tags": [
                "Mo Kweon",
                "go",
                "slack",
                "bot",
                "oauth"
            ]
        }
    ]
}