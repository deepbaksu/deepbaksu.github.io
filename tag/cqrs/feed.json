{
    "version": "https://jsonfeed.org/version/1",
    "title": "딥백수 • All posts by \"cqrs\" tag",
    "description": "우리는 '지속가능한 백수질'을 지향합니다. 고로 외롭게 공부하고 있을 당신을 응원합니다. 딥러닝에 관련된 글 뿐만 아니라, 백수생활의 넋두리도 환영합니다.",
    "home_page_url": "https://deepbaksu.github.io",
    "items": [
        {
            "id": "https://deepbaksu.github.io/2020/08/15/cqrs/",
            "url": "https://deepbaksu.github.io/2020/08/15/cqrs/",
            "title": "Command Query Responsibility Segregation",
            "date_published": "2020-08-15T11:56:22.000Z",
            "content_html": "<p>제가 서비스를 만들 때 가장 좋아하는 패턴인 <abbr title=\"Command Query Responsibility Segregation\">CQRS</abbr> 에 대해서 적어보겠습니다.</p>\n<h2 id=\"cqrs란\"><a class=\"markdownIt-Anchor\" href=\"#cqrs란\"></a> CQRS란?</h2>\n<p>원 단어를 보면 어려우 것 같지만 쉽게 얘기하면 <code>read</code> 와 <code>write</code> operation 을 나누어서 서비스를 만드는 것을 의미합니다. 특히 일반적으로 event sourcing 과 함께 구현됩니다.</p>\n<p><img src=\"/2020/08/15/cqrs/cqrs_diagram.svg\" alt=\"CQRS Diagram\" /></p>\n<h2 id=\"왜-사용하는가\"><a class=\"markdownIt-Anchor\" href=\"#왜-사용하는가\"></a> 왜 사용하는가?</h2>\n<p>쓰는 작업과 읽는 작업이 분리가 되있을 경우 (많은 서비스가 그러합니다) 한 서비스에서 둘다 처리할 경우 유용합니다. 만약에 한 서비스에서 처리하는데 쓰는 작업에 어떤 문제가 발생할 경우 읽는 작업 또한 불가능해지게 될 것입니다.</p>\n<p><img src=\"/2020/08/15/cqrs/dead_cqrs.svg\" alt=\"Dead Service Monolithic\" /></p>\n<p>또 쓰는 작업은 트래픽의 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0.01</mn><mi mathvariant=\"normal\">%</mi></mrow><annotation encoding=\"application/x-tex\">0.01\\%</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">%</span></span></span></span> 정도 밖에 안되고 읽는 서비스가 대부분의 트래픽을 차지할 수 도 있습니다.</p>\n<h2 id=\"예시\"><a class=\"markdownIt-Anchor\" href=\"#예시\"></a> 예시</h2>\n<p>CQRS 을 <a href=\"https://youtube.com/premium\">YouTube Premium</a> 서비스를 사용해 예시를 들어보도록 하겠습니다.</p>\n<p><img src=\"https://www.gstatic.com/youtube/img/promos/growth/ytr_lp2_logo_premium_desktop_552x71.png\" alt=\"YouTube Premium\" /></p>\n<h3 id=\"functional-requirements\"><a class=\"markdownIt-Anchor\" href=\"#functional-requirements\"></a> Functional Requirements</h3>\n<ul>\n<li>유저는 Youtube Premium 을 signup 할 수 있습니다.</li>\n<li>YouTube Premium 유저는 광고를 스킵합니다.</li>\n</ul>\n<p>위 요구사항을 통해 다음과 같이 두개의 서비스로 나타낼 수 있습니다.</p>\n<ul>\n<li>Premium Service\n<ul>\n<li>실제 Premium 회원 가입을 받는 서비스</li>\n</ul>\n</li>\n<li>Premium Access Service\n<ul>\n<li>Premium Access 를 가진 유저인지 확인하는 서비스</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2020/08/15/cqrs/premium_service.svg\" alt=\"Premium Service Diagram\" /></p>\n<p>어느 날 무슨 이유로 Premium Service 가 다운 됬을 경우에도 기존의 Premium User들은 아무 문제 없이 광고 없이 동영상 시청이 가능합니다.</p>\n<p><img src=\"/2020/08/15/cqrs/premium_service_down.svg\" alt=\"Premium Service is down\" /></p>\n<p>실제로도 이런 CQRS 패턴을 사용해 구현되어 있습니다.</p>\n<h2 id=\"sync\"><a class=\"markdownIt-Anchor\" href=\"#sync\"></a> Sync</h2>\n<p>그럼 이제 문제는 Query의 DB와 Command를 받는 DB의 consistency 를 어떻게 유지하는지가 관건일 것입니다. 이 문제는 <a href=\"https://microservices.io/patterns/data/event-sourcing.html\">event sourcing</a> 패턴을 사용합니다. 이벤트소싱에 대해서는 다음 포스트에서 쓰도록 하겠습니다.</p>\n<p>오신 김에 딥백수 그룹에 관심 있으신 분들은 <a href=\"/about\">소개 페이지</a> 를 방문해주세요!</p>\n",
            "tags": [
                "Mo Kweon",
                "microservice",
                "CQRS",
                "architecture",
                "software engineering"
            ]
        }
    ]
}