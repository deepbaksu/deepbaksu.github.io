{
    "version": "https://jsonfeed.org/version/1",
    "title": "딥백수 • All posts by \"software engineering\" tag",
    "description": "우리는 '지속가능한 백수질'을 지향합니다. 고로 외롭게 공부하고 있을 당신을 응원합니다. 딥러닝에 관련된 글 뿐만 아니라, 백수생활의 넋두리도 환영합니다.",
    "home_page_url": "https://deepbaksu.github.io",
    "items": [
        {
            "id": "https://deepbaksu.github.io/2020/09/01/20200902-A-Quick-Tutorial-on-Ray/",
            "url": "https://deepbaksu.github.io/2020/09/01/20200902-A-Quick-Tutorial-on-Ray/",
            "title": "(번역) Modern Parallel and Distributed Python-A Quick Tutorial on Ray",
            "date_published": "2020-09-01T15:15:52.000Z",
            "content_html": "<p>이번 포스팅은 Ray에 대해서 소개합니다.</p>\n<p>먼저 이 포스팅은 <a href=\"https://github.com/robertnishihara\">Robert Nishihara</a>의 허락을 받아, <a href=\"https://towardsdatascience.com/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray-99f8d70369b8\">Modern Parallel and Distributed Python: A Quick Tutorial on Ray</a>을 번역한 글임을 밝힙니다.</p>\n<h2 id=\"what-is-ray\"><a class=\"markdownIt-Anchor\" href=\"#what-is-ray\"></a> What is <a href=\"https://github.com/ray-project/ray\">Ray</a>?</h2>\n<p><a href=\"https://github.com/ray-project/ray\">Ray</a>는 파이썬에서 병렬, 분산 프로그래밍을 위한 오픈소스 프로젝트입니다.</p>\n<p>병렬, 분산 컴퓨팅은 현대 애플리케이션을 구성하는 요소 중 하나로 자리잡았습니다. 우리는 필요에 따라 멀티코어나 여러 대의 머신의 리소스를 최대한 활용해서 애플리케이션을 가속해야할 필요가 있습니다.</p>\n<p><em>웹 사이트를 크롤링하거나 사용자 질의에 응답하는 소프트웨어들은 누군가의 노트북에서 돌아가는 single thread기반의 프로그램이 아니고, 서로 통신하고 상호작용하는 서비스 집합이라고 볼 수 있습니다</em></p>\n<p><img src=\"cloud.jpeg\" alt=\"Cloud Computing\" /></p>\n<blockquote>\n<p>(클라우드 컴퓨팅은 메모리, 연산, 스토리지 등 다방면으로 끊임없는 확장성을 제공하고있습니다. 클라우드가 제공하는 이러한 이점에 적절하게 대응하기 위해서는 분산 어플리케이션을 만들 수 있는 새로운 도구가 필요합니다)</p>\n</blockquote>\n<p>이번 포스팅은 Ray를 사용해서 병렬,분산 어플리케이션을 만드는 방법에 대해서 설명합니다.</p>\n<h2 id=\"why-ray\"><a class=\"markdownIt-Anchor\" href=\"#why-ray\"></a> Why Ray?</h2>\n<p>많은 튜토리얼들이 <a href=\"https://docs.python.org/3/library/multiprocessing.html\">Python의 multiprocessing 모듈</a>을 어떻게 사용하는지 설명합니다.</p>\n<p>하지만 Python의 multiprocessing 모듈은 한계점을 가지고 있어 현대 애플리케이션이 요구하는 분산, 병렬에 대한 필수사항을 충족하지 못합니다.</p>\n<p>현대 애플리케이션이 요구하는 분산, 병렬처리에 대한 필수사항은 다음과 같습니다.</p>\n<ul>\n<li>같은 코드를 한대 이상의 머신(machine)에서 작동시켜야함</li>\n<li>state를 가지고, 통신이 가능한 <a href=\"https://en.wikipedia.org/wiki/Actor_model\">actor</a>와 <a href=\"https://en.wikipedia.org/wiki/Microservices\">microservice</a>를 만들 수 있어야함</li>\n<li>machine failures를 깔끔하게 다룰 수 있어야함</li>\n<li>대규모 객체와 수치 데이터를 효율적으로 다룰 수 있어야함</li>\n</ul>\n<p><a href=\"https://github.com/ray-project/ray\">Ray</a>는 위에서 언급한 요구사항을 모두 충족합니다. 또한 간단한 작업을 단순하게 만들며, 복잡한 동작을 하게끔 프로그래밍하는 것 또한 가능합니다.</p>\n<p><img src=\"ray.png\" alt=\"Ray\" /></p>\n<p><em>다른 회사들이 자신들의 Python 프로덕션을 확장하기 위해서 Ray를 어떻게 활용하고있는지 배우고싶다면, <a href=\"https://events.linuxfoundation.org/ray-summit/?utm_source=robert&amp;utm_medium=blog&amp;utm_campaign=ray_summit#featuredspeakers\">Ray Summit</a>에 등록하세요!</em></p>\n<p><img src=\"ray_summit.png\" alt=\"Ray Summit\" /></p>\n<h2 id=\"necessary-concepts\"><a class=\"markdownIt-Anchor\" href=\"#necessary-concepts\"></a> Necessary Concepts</h2>\n<p>전통적으로 프로그래밍은 <strong>1). 함수(Functions)</strong> , <strong>2).클래스(Classes)</strong> 라는 핵심 개념에 의존합니다. 생각해보면 우리는 함수와 클래스만으로 많은 애플리케이션들을 만들어왔습니다.</p>\n<p>하지만, 함수와 클래스로 구성된 애플리케이션을 분산 환경으로 마이그레이션하려고하면 함수, 클래스라는 개념을 사용할 수 없게됩니다.</p>\n<p>따라서 현재까지 알려진 병렬, 분산 도구를 활용해서 싱글 스레드 애플리케이션을 병렬, 분산 애플리케이션으로 마이그레이션을 하기 위해서는 애플리케이션 코드를 처음부터 다시 작성해야합니다.</p>\n<p>현재까지 알려진 병렬, 분산도구는 저수준에서 고수준까지 다양한 도구들이 있습니다.</p>\n<p>먼저 저수준 도구로는 메세지의 송수신을 저수준의 프리미티브로 제공하는 <a href=\"https://www.open-mpi.org/\">OpenMPI</a>, <a href=\"https://docs.python.org/3/library/multiprocessing.html\">Python Multiprocessing</a>, <a href=\"https://zeromq.org/\">ZeroMQ</a>이 있습니다. 이 도구들은 분산, 병렬 환경을 위한 강력한 기능들을 제공합니다. 하지만, 전통적인 프로그래밍과는 다른 추상화 개념을 사용합니다. 이로 인해 위 도구들을 활용해서 기존의 싱글 스레드 애플리케이션을 분산, 병렬 어플리케이션으로 마이그레이션하기 위해서는 코드 전체를 재작성해야합니다.</p>\n<p>또 다른 예로 도메인에 특화되어 고수준의 추상화를 제공하는 도구들이 있습니다. 딥러닝 모델을 학습하기 위한 <a href=\"https://www.tensorflow.org/\">TensorFlow</a>, 데이터와 SQL 처리를 위한 <a href=\"https://spark.apache.org/\">Spark</a>, 스트림 처리를 위한 <a href=\"https://flink.apache.org/\">Flink</a>가 대표적입니다. 이 도구들은 neural network나 데이터셋, 스트림에 대한 고수준의 추상화 API를 제공합니다. 하지만, 고수준 추상화를 제공하는 도구들 역시 <strong>직렬화된 프로그래밍(serial programming)</strong> 에서 사용하는 추상화와 다르기 때문에, 애플리케이션 코드 전체를 그에 맞게 재작성해줘야하는 단점이 있습니다.</p>\n<p><img src=\"distributed_computing_tools.jpeg\" alt=\"Distributed computing tools\" /></p>\n<blockquote>\n<p>(분산 컴퓨팅을 위한 도구들. 왼쪽은 저수준의 추상화 API를 지원하는 도구, 오른쪽은 고수준의 추상화 API를 제공하는 도구)</p>\n</blockquote>\n<p>Ray는 위에서 설명한 도구들과 같은 고수준, 저수준이 아닌 중간수준에 위치합니다. Ray는 함수와 클래스를 task, actor라고 불리는 분산환경에 적합한 형태로 변환하며, 이를 통해 병렬, 분산 컴퓨팅을 지원하는 메커니즘을 가지고 있습니다. 따라서 사용자들은 이전과 다르게 코드를 재작성 없이 기존의 함수와 클래스 구조를 유지하면서 분산, 병렬 프로그래밍을 할 수 있습니다.</p>\n<h2 id=\"starting-ray\"><a class=\"markdownIt-Anchor\" href=\"#starting-ray\"></a> Starting Ray</h2>\n<p>Ray의 <code>ray.init()</code>명령어는 Ray에서 사용하는 프로세스들을 모두 구동합니다.</p>\n<p>만약 클러스터 환경을 이용해서 분산 컴퓨팅을 하고자 한다면, 클러스터의 주소(address)를 입력하는 코드 라인 하나만 변경하면 됩니다.</p>\n<p><code>ray.init()</code>명령어로 구동되는 Ray의 프로세스들은 아래와 같습니다.</p>\n<ul>\n<li><strong>Worker</strong> : 파이썬의 함수를 병렬적으로 실행할 프로세스(대략 하나의 worker는 하나의 CPU 코어를 의미합니다).</li>\n<li><strong>Scheduler</strong> : task들을 worker 혹은 다른 머신에 할당하기 위한 스켸쥴러(task란 Ray에 사용되는 파이썬 함수 혹은 메소드로, Ray에 의해 스켸쥴링되는 단위).</li>\n<li><strong>Shared memory object store</strong> : 워커(worker)들간 객체를 효율적으로 공유하기 위한 공유메모리(copy 발생이 없는)</li>\n<li><strong>Inmemory database</strong> : 머신 실패(machine failure)와 같은 이벤트 상황에서 task들을 반환하기 위해 메타 데이터를 저장하는 데이터베이스</li>\n</ul>\n<p><em>Ray worker는 thread가 아니며, thread와는 다른 개념의 process입니다. Python은 GIL(Global Interpreter Lock)으로 인해 multi-threding 지원에 한계가 있습니다.</em></p>\n<h2 id=\"parallelism-with-tasks\"><a class=\"markdownIt-Anchor\" href=\"#parallelism-with-tasks\"></a> Parallelism with Tasks</h2>\n<p><code>@ray.remote</code>라는 데코레이터를 함수 위에 선언해주는 것만으로 파이썬 함수를 Ray에서 실행 가능한 <em>remote function</em> 으로 변경할 수 있습니다.</p>\n<p>(<em>remote function은 Ray의 프로세스에 의해 비동기적으로 실행됩니다.</em>)</p>\n<p>아래 예제와 같이 함수 <code>f</code>를 <code>@ray.remote</code> 데코레이터를 통해서 <em>remote function</em> 으로 변경했다면, <code>f.remote()</code>를 호출해서 함수를 실행할 수 있습니다. 이때, 호출된 <code>f.remote()</code>는 즉각적으로 future를 반환하고 실제 함수의 실행은 백그라운드에서 진행됩니다.</p>\n<p>(<em><a href=\"https://en.wikipedia.org/wiki/Futures_and_promises\">future</a>는 나중에 반환될 함수의 출력값에 대한 참조입니다.</em>)</p>\n<p>아래 예제에서 <code>f.remote()</code>에 대한 호출이 즉시 반환되고 다음 <em>remote function</em> 이 실행되기 때문에, 백그라운드에서 실행되는 <code>f</code>에 대한 4개의 복사본(task)은 단순히 해당 라인을 4번 실행하는 것으로 분산, 병렬로 실행할 수 있습니다.</p>\n<p>파이썬 함수 <code>f</code>를 <em>remote function</em> 으로 바꾸기 위해서는 함수에 <code>@ray.remote</code>라는 데코레이터를 선언해줘야합니다. 그리고 함수를 <code>f.remote()</code>로 호출하면 즉시 future를 리턴합니다. 그리고 실제 함수의 실행은 백그라운드에서 실행됩니다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ray</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start Ray.</span></span><br><span class=\"line\">ray.init()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ray.remote</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>):</span></span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start 4 tasks in parallel.</span></span><br><span class=\"line\">result_ids = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">4</span>):</span><br><span class=\"line\">    result_ids.append(f.remote(i))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Wait for the tasks to complete and retrieve the results.</span></span><br><span class=\"line\"><span class=\"comment\"># With at least 4 cores, this will take 1 second.</span></span><br><span class=\"line\">results = ray.get(result_ids)  <span class=\"comment\"># [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"task-dependencies\"><a class=\"markdownIt-Anchor\" href=\"#task-dependencies\"></a> Task Dependencies</h3>\n<p>task는 또 다른 task에 의존할 수 있습니다.</p>\n<p>아래 예제에서 <code>multiply_matrices</code> task는 두개의 <code>create_matrix</code> task의 결과를 사용합니다. 따라서 첫번째 두 task의 출력은 자동으로 세번째 task의 인자로 입력됩니다.</p>\n<p>결론적으로, 아래 예제를 실행해보면, <code>multiply_matrices</code>는 첫번째 두 task의 출력의 값이 반환되기 전까지는 실행되지 않습니다.</p>\n<p>이러한 방식으로 task들을 arbitrary DAG dependencies로 구성할 수 있습니다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ray.remote</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_matrix</span>(<span class=\"params\">size</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.random.normal(size=size)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ray.remote</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multiply_matrices</span>(<span class=\"params\">x, y</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> np.dot(x, y)</span><br><span class=\"line\"></span><br><span class=\"line\">x_id = create_matrix.remote([<span class=\"number\">1000</span>, <span class=\"number\">1000</span>])</span><br><span class=\"line\">y_id = create_matrix.remote([<span class=\"number\">1000</span>, <span class=\"number\">1000</span>])</span><br><span class=\"line\">z_id = multiply_matrices.remote(x_id, y_id)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get the results.</span></span><br><span class=\"line\">z = ray.get(z_id)</span><br></pre></td></tr></table></figure>\n<h3 id=\"aggregating-values-efficiently\"><a class=\"markdownIt-Anchor\" href=\"#aggregating-values-efficiently\"></a> Aggregating Values Efficiently</h3>\n<p>task 의존성을 잘 설계하면 효율적인 방식으로 작업을 수행할 수 있습니다.</p>\n<p>예를 들어 아래의 그림처럼 8개의 정수를 더한다고 생각해봅시다.</p>\n<p>매우 간단한 예제이지만, 실제로 이러한 형태로 큰 벡터를 통합하는 것은 애플리케이션에 큰 병목이 되기도 합니다. 이런 병목 지점에서 task 의존성을 잘 설계한다면, 단 한줄의 코드 변경으로 시간 복잡도를 선형 시간에서 로그메틱 시간으로 변경할 수 있습니다.</p>\n<p><img src=\"aggregation.jpeg\" alt=\"Aggregation\" /></p>\n<blockquote>\n<p>(두 연산 그래프는 같은 결과를 반환하지만, 좌측 그림은 의존성 그래프의 깊이가 7이며, 우측 그림은 의존성 그래프의 깊이가 3입니다. 이 경우 우측 연산 그래프의 연산이 더 빠릅니다)</p>\n</blockquote>\n<p>위에서 설명한데로 하나의 task에서 생성된 출력을 다른 task의 입력으로 사용하기 위해서는 첫번째 task로부터 반환받은 future를 두번째 task의 입력으로 넣으면 됩니다.</p>\n<p>이때, 두번째 task가 첫번째 task의 출력을 의존하고있으면 두번째 task는 첫번째 task가 끝나기 전에는 실행되지 않습니다.</p>\n<p>task 의존성은 자동으로 ray의 스켸쥴러가 추적하고 관리하므로, 만약 분산환경일 경우, 첫번째 task의 출력은 자동으로 두번째 task가 있는 머신으로 보내져 실행되게됩니다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ray.remote</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">x, y</span>):</span></span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Aggregate the values slowly. This approach takes O(n) where n is the</span></span><br><span class=\"line\"><span class=\"comment\"># number of values being aggregated. In this case, 7 seconds.</span></span><br><span class=\"line\">id1 = add.remote(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">id2 = add.remote(id1, <span class=\"number\">3</span>)</span><br><span class=\"line\">id3 = add.remote(id2, <span class=\"number\">4</span>)</span><br><span class=\"line\">id4 = add.remote(id3, <span class=\"number\">5</span>)</span><br><span class=\"line\">id5 = add.remote(id4, <span class=\"number\">6</span>)</span><br><span class=\"line\">id6 = add.remote(id5, <span class=\"number\">7</span>)</span><br><span class=\"line\">id7 = add.remote(id6, <span class=\"number\">8</span>)</span><br><span class=\"line\">result = ray.get(id7)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Aggregate the values in a tree-structured pattern. This approach</span></span><br><span class=\"line\"><span class=\"comment\"># takes O(log(n)). In this case, 3 seconds.</span></span><br><span class=\"line\">id1 = add.remote(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">id2 = add.remote(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">id3 = add.remote(<span class=\"number\">5</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">id4 = add.remote(<span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\">id5 = add.remote(id1, id2)</span><br><span class=\"line\">id6 = add.remote(id3, id4)</span><br><span class=\"line\">id7 = add.remote(id5, id6)</span><br><span class=\"line\">result = ray.get(id7)</span><br></pre></td></tr></table></figure>\n<p>위의 코드는 명확합니다. 하지만, 이를 <code>while</code> loop를 통해 구현한다면 더 간결하게 구현할 수 있습니다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Slow approach.</span></span><br><span class=\"line\">values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">len</span>(values) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">    values = [add.remote(values[<span class=\"number\">0</span>], values[<span class=\"number\">1</span>])] + values[<span class=\"number\">2</span>:]</span><br><span class=\"line\">result = ray.get(values[<span class=\"number\">0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Fast approach.</span></span><br><span class=\"line\">values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"built_in\">len</span>(values) &gt; <span class=\"number\">1</span>:</span><br><span class=\"line\">    values = values[<span class=\"number\">2</span>:] + [add.remote(values[<span class=\"number\">0</span>], values[<span class=\"number\">1</span>])]</span><br><span class=\"line\">result = ray.get(values[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<h2 id=\"from-classes-to-actors\"><a class=\"markdownIt-Anchor\" href=\"#from-classes-to-actors\"></a> From Classes to Actors</h2>\n<p>클래스없이 좋은 애플리케이션을 만드는 것은 어려운 일입니다. 그리고 이는 분산환경에서도 마찬가지로 어렵습니다.</p>\n<p>클래스 데코레이터 <code>@ray.remote</code>를 사용하면 Ray에서 파이썬 클래스를 사용할 수 있습니다. 클래스를 인스턴스화하면 Ray는 새로운 액터(Actor)를 생성합니다. 액터는 분산환경 어딘가에서 실행되지만 객체의 복제본(object copy)을 유지하는 프로세스입니다.</p>\n<p>액터의 메소드를 실행하면 Ray는 해당 메소드를 액터 프로세스 위에서 작동하는 task로 변환합니다. 액터 프로세스 위에서 작동하는 task는 액터의 상태(state)에 접근이 가능하고 상태를 변경할 수 있습니다. 이러한 방법으로 액터는 액터의 상태값을 여러 task간 공유합니다.</p>\n<p>개별적인 액터는 메소드를 직렬로 실행하며(블럭킹), 액터의 메소드는 atomic 속성을 갖습니다. 따라서 race condition이 발생하지 않게됩니다. 액터를 이용한 병렬성은 다수의 액터를 생성하는 방식으로 구현합니다.</p>\n<p>아래 예제는 액터를 사용하는 간단한 예제입니다. <code>Counter.remote()</code>는 새로운 액터 프로세스를 생성합니다.</p>\n<p>액터 프로세스는 <code>Counter</code> 객체의 복사본을 갖으며, <code>c.get_value.remote()</code>와 <code>c.inc.remote()</code>는 원격 액터 프로세스(remote actor process)에서 task를 실행하고 액터의 상태를 변경합니다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ray.remote</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.x = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inc</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.x += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_value</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create an actor process.</span></span><br><span class=\"line\">c = Counter.remote()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Check the actor&#x27;s counter value.</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(ray.get(c.get_value.remote()))  <span class=\"comment\"># 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Increment the counter twice and check the value again.</span></span><br><span class=\"line\">c.inc.remote()</span><br><span class=\"line\">c.inc.remote()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(ray.get(c.get_value.remote()))  <span class=\"comment\"># 2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"actor-handles\"><a class=\"markdownIt-Anchor\" href=\"#actor-handles\"></a> Actor Handles</h3>\n<p>위에서 우리는 파이썬의 메인 스크립트에서 액터의 메소드를 실행하는 예제를 살펴봤습니다.</p>\n<p>액터의 강력한 장점은 핸들(handle)을 액터에 전달할 수 있는 것입니다. 이는 다른 액터나 다른 task가 동일한 액터의 메소드를 호출할 수 있게 해줍니다.</p>\n<p>아래 예제는 메세지를 저장하는 액터를 생성합니다. 몇몇의 worker task는 반복적으로 messages를 액터로 푸쉬합니다. 그리고 파이썬 메인 스크립트는 주기적으로 이 메세지를 읽습니다.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ray.remote</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageActor</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.messages = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_message</span>(<span class=\"params\">self, message</span>):</span></span><br><span class=\"line\">        self.messages.append(message)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_and_clear_messages</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        messages = self.messages</span><br><span class=\"line\">        self.messages = []</span><br><span class=\"line\">        <span class=\"keyword\">return</span> messages</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Define a remote function which loops around and pushes</span></span><br><span class=\"line\"><span class=\"comment\"># messages to the actor.</span></span><br><span class=\"line\"><span class=\"meta\">@ray.remote</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">worker</span>(<span class=\"params\">message_actor, j</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        message_actor.add_message.remote(</span><br><span class=\"line\">            <span class=\"string\">&quot;Message &#123;&#125; from worker &#123;&#125;.&quot;</span>.<span class=\"built_in\">format</span>(i, j))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Create a message actor.</span></span><br><span class=\"line\">message_actor = MessageActor.remote()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Start 3 tasks that push messages to the actor.</span></span><br><span class=\"line\">[worker.remote(message_actor, j) <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>)]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Periodically get the messages and print them.</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">    new_messages = ray.get(message_actor.get_and_clear_messages.remote())</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;New messages:&quot;</span>, new_messages)</span><br><span class=\"line\">    time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># This script prints something like the following:</span></span><br><span class=\"line\"><span class=\"comment\"># New messages: []</span></span><br><span class=\"line\"><span class=\"comment\"># New messages: [&#x27;Message 0 from worker 1.&#x27;, &#x27;Message 0 from worker 0.&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\"># New messages: [&#x27;Message 0 from worker 2.&#x27;, &#x27;Message 1 from worker 1.&#x27;, &#x27;Message 1 from worker 0.&#x27;, &#x27;Message 1 from worker 2.&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\"># New messages: [&#x27;Message 2 from worker 1.&#x27;, &#x27;Message 2 from worker 0.&#x27;, &#x27;Message 2 from worker 2.&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\"># New messages: [&#x27;Message 3 from worker 2.&#x27;, &#x27;Message 3 from worker 1.&#x27;, &#x27;Message 3 from worker 0.&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\"># New messages: [&#x27;Message 4 from worker 2.&#x27;, &#x27;Message 4 from worker 0.&#x27;, &#x27;Message 4 from worker 1.&#x27;]</span></span><br><span class=\"line\"><span class=\"comment\"># New messages: [&#x27;Message 5 from worker 2.&#x27;, &#x27;Message 5 from worker 0.&#x27;, &#x27;Message 5 from worker 1.&#x27;]</span></span><br></pre></td></tr></table></figure>\n<p>Ray의 액터는 매우 강력합니다. 액터는 파이썬의 클래스를 가져와서 다른 액터와의 작업 혹은 다른 애플리케이션에 질의할 수 있는 마이크로 서비스로 인스턴스화할 수 있습니다.</p>\n<p>task와 액터는 Ray가 제공하는 핵심적인 추상입니다. 이 두 가지 개념은 매우 일반적이면서 정교한 애플리케이션 구현에 사용할 수 있습니다.</p>\n<p>Ray는 딥러닝에 사용되는 정교한 애플리케이션 중 하나인 <a href=\"https://docs.ray.io/en/latest/rllib.html\">분산 강화학습</a>, <a href=\"https://docs.ray.io/en/latest/tune/index.html\">하이퍼파라미터 튜닝 도구</a>, <a href=\"https://docs.ray.io/en/latest/pandas_on_ray.html\">가속화된 판다스</a>를 제공하니 한번 살펴보시기 바랍니다.</p>\n<p>또한 이런 기술적인 내용을 함께 논의해보고 싶으시다면 딥백수에서 함께하시면 좋을 것 같습니다. <a href=\"/about\">딥백수 소개 페이지</a></p>\n<h2 id=\"reference\"><a class=\"markdownIt-Anchor\" href=\"#reference\"></a> Reference</h2>\n<ol>\n<li><a href=\"https://towardsdatascience.com/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray-99f8d70369b8\">Modern Parallel and Distributed Python: A Quick Tutorial on Ray</a></li>\n</ol>\n",
            "tags": [
                "software engineering",
                "Martin Hwang",
                "Ray",
                "distributed computing",
                "parallel computing"
            ]
        },
        {
            "id": "https://deepbaksu.github.io/2020/08/15/cqrs/",
            "url": "https://deepbaksu.github.io/2020/08/15/cqrs/",
            "title": "Command Query Responsibility Segregation",
            "date_published": "2020-08-15T11:56:22.000Z",
            "content_html": "<p>제가 서비스를 만들 때 가장 좋아하는 패턴인 <abbr title=\"Command Query Responsibility Segregation\">CQRS</abbr> 에 대해서 적어보겠습니다.</p>\n<h2 id=\"cqrs란\"><a class=\"markdownIt-Anchor\" href=\"#cqrs란\"></a> CQRS란?</h2>\n<p>원 단어를 보면 어려우 것 같지만 쉽게 얘기하면 <code>read</code> 와 <code>write</code> operation 을 나누어서 서비스를 만드는 것을 의미합니다. 특히 일반적으로 event sourcing 과 함께 구현됩니다.</p>\n<p><img src=\"/2020/08/15/cqrs/cqrs_diagram.svg\" alt=\"CQRS Diagram\" /></p>\n<h2 id=\"왜-사용하는가\"><a class=\"markdownIt-Anchor\" href=\"#왜-사용하는가\"></a> 왜 사용하는가?</h2>\n<p>쓰는 작업과 읽는 작업이 분리가 되있을 경우 (많은 서비스가 그러합니다) 한 서비스에서 둘다 처리할 경우 유용합니다. 만약에 한 서비스에서 처리하는데 쓰는 작업에 어떤 문제가 발생할 경우 읽는 작업 또한 불가능해지게 될 것입니다.</p>\n<p><img src=\"/2020/08/15/cqrs/dead_cqrs.svg\" alt=\"Dead Service Monolithic\" /></p>\n<p>또 쓰는 작업은 트래픽의 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>0.01</mn><mi mathvariant=\"normal\">%</mi></mrow><annotation encoding=\"application/x-tex\">0.01\\%</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.80556em;vertical-align:-0.05556em;\"></span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mord\">1</span><span class=\"mord\">%</span></span></span></span> 정도 밖에 안되고 읽는 서비스가 대부분의 트래픽을 차지할 수 도 있습니다.</p>\n<h2 id=\"예시\"><a class=\"markdownIt-Anchor\" href=\"#예시\"></a> 예시</h2>\n<p>CQRS 을 <a href=\"https://youtube.com/premium\">YouTube Premium</a> 서비스를 사용해 예시를 들어보도록 하겠습니다.</p>\n<p><img src=\"https://www.gstatic.com/youtube/img/promos/growth/ytr_lp2_logo_premium_desktop_552x71.png\" alt=\"YouTube Premium\" /></p>\n<h3 id=\"functional-requirements\"><a class=\"markdownIt-Anchor\" href=\"#functional-requirements\"></a> Functional Requirements</h3>\n<ul>\n<li>유저는 Youtube Premium 을 signup 할 수 있습니다.</li>\n<li>YouTube Premium 유저는 광고를 스킵합니다.</li>\n</ul>\n<p>위 요구사항을 통해 다음과 같이 두개의 서비스로 나타낼 수 있습니다.</p>\n<ul>\n<li>Premium Service\n<ul>\n<li>실제 Premium 회원 가입을 받는 서비스</li>\n</ul>\n</li>\n<li>Premium Access Service\n<ul>\n<li>Premium Access 를 가진 유저인지 확인하는 서비스</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2020/08/15/cqrs/premium_service.svg\" alt=\"Premium Service Diagram\" /></p>\n<p>어느 날 무슨 이유로 Premium Service 가 다운 됬을 경우에도 기존의 Premium User들은 아무 문제 없이 광고 없이 동영상 시청이 가능합니다.</p>\n<p><img src=\"/2020/08/15/cqrs/premium_service_down.svg\" alt=\"Premium Service is down\" /></p>\n<p>실제로도 이런 CQRS 패턴을 사용해 구현되어 있습니다.</p>\n<h2 id=\"sync\"><a class=\"markdownIt-Anchor\" href=\"#sync\"></a> Sync</h2>\n<p>그럼 이제 문제는 Query의 DB와 Command를 받는 DB의 consistency 를 어떻게 유지하는지가 관건일 것입니다. 이 문제는 <a href=\"https://microservices.io/patterns/data/event-sourcing.html\">event sourcing</a> 패턴을 사용합니다. 이벤트소싱에 대해서는 다음 포스트에서 쓰도록 하겠습니다.</p>\n<p>오신 김에 딥백수 그룹에 관심 있으신 분들은 <a href=\"/about\">소개 페이지</a> 를 방문해주세요!</p>\n",
            "tags": [
                "Mo Kweon",
                "microservice",
                "CQRS",
                "architecture",
                "software engineering"
            ]
        }
    ]
}